
# multiple round, teached by gemini pro

# generate data for training
# {"query": "55555", "response": "66666", "images": ["image_path"]}
# CUDA_VISIBLE_DEVICES=0 swift sft --model_type minicpm-v-v2-chat --dataset ~/data/agiqa-3k/directly_train_minicpm.jsonl --val_dataset ~/data/agiqa-3k/directly_test_minicpm.jsonl  --num_train_epochs=20
# CUDA_VISIBLE_DEVICES=0 swift infer --ckpt_dir /home/cuichuan/workspace/iqa/AGIQA-test/output/minicpm-v-v2-chat/v3-20240524-090838/checkpoint-2200 --load_dataset_config true --show_dataset_sample -1 

# on 4090: `NCCL_P2P_DISABLE="1"` and `NCCL_IB_DISABLE="1"

import json
from pathlib import Path
import random

import pandas as pd
from tqdm import tqdm
import copy


PROMPT = '''Take a close look at this image and tell me everything you can about what you see. I'm curious to know how well it matches the original prompt used to generate it: '{prompt}'. Could you also rate the image on a scale of 0 to 5 for these aspects: overall quality, how well it reflects the prompt? Please provide the float type scores in a JSON format using these keys: 'image_quality_score', 'prompt_alignment_score'.'''

PROMPT_QUALITY = '''Take a close look at this AI-generated image and tell me everything you can about what you see. It's original prompt is: '{prompt}'. Could you please help to analyze the image's quality?'''

PROMPT_QUALITY = '''Please closely examine this AI-generated image and provide a detailed analysis of its content and quality. The original prompt for the image was: '{prompt}' What can you deduce about the image based on this prompt, and how would you assess its overall quality?'''

PROMPT_ALIGNMENT = '''Please closely examine this AI-generated image and provide a detailed analysis of how well it aligns with the original prompt: '{prompt}'.'''

PROMPT_QUALITY_2nd = '''Now based on your analysis, could you please help to rate the image based on it's overall quality? Please give me one word from the list [bad, poor, fair, good, excellent]. Notice that quality word in the list means from low to high.'''

PROMPT_QUALITY_2nd = '''Based on your analysis, could you please rate the image's overall quality? Choose one word from the following list: [bad, poor, fair, good, excellent], where the words range from low to high quality.'''

PROMPT_ALIGNMENT_2nd = '''Based on your analysis, could you please rate the image's alignment with its original prompt? Choose one word from the following list: [bad, poor, fair, good, excellent], where the words indicate the degree of alignment from low to high.'''

PROMPT_AUTHENTICITY = '''Please closely examine this AI-generated image and provide a detailed analysis of its authenticity. The original prompt for the image was: '{prompt}'. How closely does the image resemble real artworks or scenes? Highlight any parts of the image that appear non-real or artificial.
'''

PROMPT_AUTHENTICITY_2nd = '''Based on your analysis, could you please rate the image's authenticity? Choose one word from the following list: [bad, poor, fair, good, excellent], where the words indicate the degree of authenticity from low to high.'''

PROMPT_ALL = '''Please carefully analyze this AI-generated image based on the prompt: "{prompt}". Focus on the following three aspects: Quality, Alignment, and Authenticity.

Quality: Evaluate the overall quality of the image, considering composition, clarity, and any noticeable flaws.
Alignment: Assess how well the image aligns with the given prompt, noting which elements are accurately reflected and which may be missing or misinterpreted.
Authenticity: Discuss the image's resemblance to real artworks, highlighting any parts that appear artificial or unrealistic.
'''
PROMPT_Q_n_A = '''Please carefully analyze this AI-generated image based on the prompt: "{prompt}". Focus on the following two aspects: Quality, Alignment.

Quality: Evaluate the overall quality of the image, considering composition, clarity, and any noticeable flaws.
Alignment: Assess how well the image aligns with the given prompt, noting which elements are accurately reflected and which may be missing or misinterpreted.
'''



# data_path = Path("./data/agiqa-3k")
# data_path = Path('./data/AIGCIQA2023')
data_path = Path('./data/aigciqa-30k')
descriptor = pd.read_csv(data_path / 'data.csv')
intermediate_answer = pd.read_csv(data_path / 'gemini_pro_analysis_explaination.csv', index_col="name")
image_dir = data_path / 'images'
# gemini_on_minicpmv2_5_train_all.json, 
# intermediate_answer generated by gemini pro and trained on minicpmv2.5
output_file = data_path / 'gemini_on_minicpmv2_5_{stage}_{aspect}_new_geminipro_q_n_a.json'  

def output_file_write(stage, aspect, data):
    with open(str(output_file).format(stage=stage, aspect=aspect), 'w') as f:
        json.dump(data, f, indent=4)

def extract_quality_from_intermediate_(inter: str):
    # it's a json but maybe quote in string not escaped
    inter = inter.replace("\n", "")
    inter = inter.strip()
    q_start = inter.index("\"quality_explanation\":")
    a_start = inter.index("\"alignment_explanation\":")
    txt_between = inter[q_start+22:a_start]
    txt_between = txt_between.strip()
    txt_between = txt_between.removesuffix("\",")
    txt_between = txt_between.removeprefix("\"")
    return txt_between

def extract_alignment_from_intermediate_(inter: str):
    # it's a json but maybe quote in string not escaped
    inter = inter.replace("\n", "")
    inter = inter.strip()
    a_start = inter.index("\"alignment_explanation\":")
    try:
        au_start = inter.index("\"authenticity_explanation\":")
    except:
        au_start = inter.index("}")
    txt_between = inter[a_start+24:au_start]
    txt_between = txt_between.strip()
    txt_between = txt_between.removesuffix("\",")
    txt_between = txt_between.removeprefix("\"")
    return txt_between

def extract_authenticity_from_intermediate_(inter: str):
    # it's a json but maybe quote in string not escaped
    inter = inter.replace("\n", "")
    inter = inter.strip()
    au_start = inter.index("\"authenticity_explanation\":")
    txt_between = inter[au_start+27:]
    txt_between = txt_between.strip()
    txt_between = txt_between.removesuffix("\"}")
    txt_between = txt_between.removeprefix("\"")
    return txt_between

def mos2ans(mos):
    if mos < 1:    # for AIGCIQA2023 scores are 0~100, but aigciqa-30k are 0~5! fuck!
        answer = 'bad'
    elif mos < 2:
        answer = 'poor'
    elif mos < 3:
        answer = 'fair'
    elif mos < 4:
        answer = 'good'
    else:
        answer = 'excellent'
    return answer

def split_data(data_path, result):

    if 'AIGCIQA2023' in str(data_path):
        # split 3:1 train test
        split = int(len(result) * 0.75)
        train_data = result[:split]
        test_data = result[split:]
        val_data = test_data
    if 'agiqa-3k' in str(data_path):
        # split 8:2 train test
        split = int(len(result) * 0.8)
        train_data = result[:split]
        test_data = result[split:]
        val_data = test_data
    if 'aigciqa-30k' in str(data_path):
        # 7:1:2 according to info_train, info_val, info_test .csv
        info_train = pd.read_csv(data_path / 'info_train.csv')
        info_val = pd.read_csv(data_path / 'info_val.csv')
        info_test = pd.read_csv(data_path / 'info_test.csv')

        train_data = []
        val_data = []
        test_data = []

        for res in result:
            img_name = Path(res['image']).name
            if img_name in info_train['name'].values:
                train_data.append(res)
            elif img_name in info_val['name'].values:
                val_data.append(res)
            elif img_name in info_test['name'].values:
                test_data.append(res)
            else:
                print(f"Error: {img_name} not found in info_train, info_val, info_test")
        print(f"train: {len(train_data)}, val: {len(val_data)}, test: {len(test_data)}")

    return train_data, val_data, test_data

def prepare_data_for_train():

    result_quality = []
    result_alignment = []
    result_authenticity = []
    item_list = list(descriptor.iterrows())
    random.shuffle(item_list)
    bar = tqdm(item_list)
    idx_ = 0
    for idx, row in bar:
        img_path = str((image_dir / row['name']).resolve())
        img_name = row['name']
        is_success = intermediate_answer.loc[img_name]["success"]
        if not is_success:
            print(f"skip {img_name}")
            continue
        intermediate_ = intermediate_answer.loc[img_name]["result"]
        intermediate_ = intermediate_.replace("\n", "")
        intermediate_ = intermediate_.strip()
        intermediate_ = intermediate_.removeprefix("```json")
        intermediate_ = intermediate_.removesuffix("```")
        q = extract_quality_from_intermediate_(intermediate_)
        a = extract_alignment_from_intermediate_(intermediate_)
        # au = extract_authenticity_from_intermediate_(intermediate_)

        prompt_q = PROMPT_QUALITY.format(prompt=row['prompt'])
        # answer = {'image_quality_score:': row['mos_quality'], 'prompt_alignment_score': row['mos_align']}
        # prompt_a = PROMPT_ALIGNMENT.format(prompt=row['prompt'])
        # prompt_au = PROMPT_AUTHENTICITY.format(prompt=row['prompt'])
        prompt_all = PROMPT_ALL.format(prompt=row['prompt'])
        prompt_Q_n_A = PROMPT_Q_n_A.format(prompt=row['prompt'])
        # answer_q = mos2ans(row['mos_quality'])
        # answer_a = mos2ans(row['mos_align'])
        answer_q = mos2ans(row['mos'])  # only q

        # only quality mos in AIGCIQA-20k
        # answer_a = mos2ans(row['mos_correspondence'])
        # answer_au = mos2ans(row['mos_authenticity'])
        
        # answer_au = mos2ans(row[''])
        # answer to string
        data_all = {'id': str(idx_), 
                'image': img_path,
                'conversations': [{
                    'role': 'user',
                    'content': '<image>\n' + prompt_all
                },
                {
                    'role': 'assistant',
                    'content': f'Quality: {q}\n Alignment: {a}'
                },
                ]
                }   # minicpm format
        data_quality = {'id': str(idx_), 
                'image': img_path,
                'conversations': [{
                    'role': 'user',
                    'content': '<image>\n' + prompt_Q_n_A
                },
                {
                    'role': 'assistant',
                    'content': f'Quality: {q}\n Alignment: {a}'
                },
                ]
                }   # minicpm format
        # data_alignment = {'id': str(idx_), 
        #         'image': img_path,
        #         'conversations': [{
        #             'role': 'user',
        #             'content': '<image>\n' + prompt_a
        #         },
        #         {
        #             'role': 'assistant',
        #             'content': f'{a}'
        #         },
        #         ]
        #         }   # minicpm format
        # data_authenticity = {'id': str(idx_), 
        #         'image': img_path,
        #         'conversations': [{
        #             'role': 'user',
        #             'content': '<image>\n' + prompt_au
        #         },
        #         {
        #             'role': 'assistant',
        #             'content': f'{au}'
        #         },
        #         ]
        #         }   # minicpm format
        # append answer
        data_answers = {
            'quality': [
                {
                    'role': 'user',
                    'content': PROMPT_QUALITY_2nd
                },
                {
                    'role': 'assistant',
                    'content': answer_q
                }
            ],
            # 'alignment': [
            #     {
            #         'role': 'user',
            #         'content': PROMPT_ALIGNMENT_2nd
            #     },
            #     {
            #         'role': 'assistant',
            #         'content': answer_a
            #     }
            # ],
            # 'authenticity': [
            #     {
            #         'role': 'user',
            #         'content': PROMPT_AUTHENTICITY_2nd
            #     },
            #     {
            #         'role': 'assistant',
            #         'content': answer_au
            #     }
            # ]
        }
        for d_a_m in data_answers['quality']:   # data answers message
            data_quality['conversations'].append(d_a_m)
        # for d_a_m in data_answers['alignment']:   # data answers message
        #     data_alignment['conversations'].append(d_a_m)
        # for d_a_m in data_answers['authenticity']:   # data answers message
        #     data_authenticity['conversations'].append(d_a_m)

        # data = {
        #     'query': prompt,
        #     'response': answer,
        #     'images': [str((image_dir / row['name']).resolve())]
        # }
        idx_ += 1
        result_quality.append(data_quality)
        # result_alignment.append(data_alignment)
        # result_authenticity.append(data_authenticity)

    random_idx = list(range(0, len(result_quality)))
    random.shuffle(random_idx)
    result_quality = [result_quality[i] for i in random_idx]
    # result_alignment = [result_alignment[i] for i in random_idx]
    # result_authenticity = [result_authenticity[i] for i in random_idx]
    
    # if len(result_quality) 
    train_q, val_q, test_q = split_data(data_path, result_quality)
    # train_al, val_al, test_al = split_data(data_path, result_alignment)
    # train_au, val_au, test_au = split_data(data_path, result_authenticity)
    
    output_file_write('train', 'quality', train_q)
    output_file_write('val', 'quality', val_q)
    output_file_write('test', 'quality', test_q)
    # output_file_write('train', 'alignment', train_al)
    # output_file_write('val', 'alignment', val_al)
    # output_file_write('test', 'alignment', test_al)
    # output_file_write('train', 'authenticity', train_au)
    # output_file_write('val', 'authenticity', val_au)
    # output_file_write('test', 'authenticity', test_au)


prepare_data_for_train()
